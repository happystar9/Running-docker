
@using TetrisShared.DTOs
@inject IChatService chatService
@inject AuthenticationStateProvider AuthStateProvider
@inject UserManager<ApplicationUser> UserManager
@inject IPlayerService playerService
@inject IHttpClientFactory HttpClientFactory
@inject IJSRuntime JSRuntime

<script>
    function scrollToBottom(element) {
    if (element) {
    element.scrollTop = element.scrollHeight;
    }
    }
</script>



<div class="chat-container">
    <div class="chat-messages" @ref= "chatMessagesDiv">
        @if (messages != null)
        {
            foreach (var message in messages)
            {
                <div class="chat-message">
                    <div class="chat-username">@message.PlayerUsername</div>
                    <div class="chat-time">@message.TimeSent</div>
                    <div class="chat-text">@message.Message</div>
                </div>
            }
        }
        else
        {
            <p>No messages yet.</p>
        }
    </div>

    <div class="chat-input">
        <EditForm class="message-form" Model="@this" OnValidSubmit="SendMessage">
            <InputText class="form-control" @bind-Value="newMessageText" placeholder="Type a message..." />
            @if (playerUsername is not null)
            {
                <button type="submit" class="btn btn-primary">Send</button>
            }
        </EditForm>
        @if (playerUsername is null)
        {
            <p class="help-message">You must be logged in to send messages.</p>
        }
    </div>
</div>

@code {
    [Parameter]
    public string AuthId { get; set; }

    [Parameter]
    public PlayerDto CurrentPlayer { get; set; }

    private HttpClient httpClient;
    List<ChatDto> messages = null;
    int playerId;
    string playerUsername;
    AuthenticationState authState;
    string newMessageText;
    private ElementReference chatMessagesDiv; 


    protected override async Task OnInitializedAsync()
    {
        httpClient = HttpClientFactory.CreateClient("TetrisApi");


        authState = await AuthStateProvider.GetAuthenticationStateAsync();

        //Console.WriteLine(authState.User.Identity?.IsAuthenticated);

        var user = authState.User;
        chatService.OnMessage += async () => await LoadMessages();

        //every time the state changes, we need to call LoadMessages



        // chatService.OnMessage +=  () =>  StateHasChanged();

        if (user.Identity?.IsAuthenticated == true)
        {
            if (CurrentPlayer is not null)
            {
                playerId = CurrentPlayer.Id;
                playerUsername = CurrentPlayer.Username;
            }
        }

        await LoadMessages();
    }

    private async Task LoadMessages()
    {
        messages = await httpClient.GetFromJsonAsync<List<ChatDto>>("api/chat");
        messages = messages.OrderBy(m => m.TimeSent).ToList();

        StateHasChanged();

    }


    private async Task SendMessage()
    {
        ChatDto chatDto = new ChatDto()
            {
                PlayerId = playerId,
                Message = newMessageText
            };

        await httpClient.PostAsJsonAsync("api/chat", chatDto);
        newMessageText = "";
        await LoadMessages();

    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || messages?.Count > 0)
        {
            await ScrollToBottom();
            await LoadMessages();
        }
    }
    
    private async Task ScrollToBottom()
    {
        await JSRuntime.InvokeVoidAsync("scrollToBottom", chatMessagesDiv);
    }

}